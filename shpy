#!/usr/bin/env sh

# Ensure SHPY_PATH is set
if [ -z "${SHPY_PATH:+is_set_and_not_null}" ]; then
  echo 'Error: SHPY_PATH is not set as the path to shpy' >&2
  return 1
fi

# PUBLIC API   .-.     .-.     .-.     .-.     .-.     .-.     .-.     .-.
# `._.'   `._.'   `._.'   `._.'   `._.'   `._.'   `._.'   `._.'   `._.'   `

createSpy() {
    # shellcheck disable=SC2039
    local usage status_codes outputs_count outputs_dir errors_count errors_dir spy_name

    usage='Usage: createSpy [[-r status] [-o output] [-e output] ...] name

Creates new spies and resets existing spies

Options can be passed multiple times to create a sequence
Once the sequence finishes, the last value is always used

Options:
  -r    Sets the status code returned by the spy when invoked
  -o    Sets the output sent to stdout when the spy is invoked
        When used with -e, stdout is written to first
  -e    Sets the output sent to stderr when the spy is invoked
        When used with -o, stdout is written to first'

    if [ $# -eq 0 ]; then
        printf '%s\n' "$usage"
        return 1
    fi

    # Loop over all arguments and set `spy_name` to the last one
    for spy_name in "$@"; do :; done

    # Ensure shpy is initialized
    _shpyInit

    # Create empty directories for stdout and stderr outputs
    outputs_dir="$_shpy_spies_dir/outputs/$spy_name"
    errors_dir="$_shpy_spies_dir/errors/$spy_name"

    (shpy_remove_dir_tree "$outputs_dir" && shpy_ensure_dir "$outputs_dir") \
      || shpy_die "Error: Failed to create empty spy stdout directory"
    (shpy_remove_dir_tree "$errors_dir" && shpy_ensure_dir "$errors_dir") \
      || shpy_die "Error: Failed to create empty spy stderr directory"

    outputs_count=0
    errors_count=0

    # Parse command line arguments
    OPTIND=1
    while getopts :o:r:e: opt; do
        case "$opt" in
            o)
              # Write the contents to the stdout directory
              echo "$OPTARG" > "$outputs_dir/$outputs_count"
              outputs_count=$((outputs_count + 1))
              ;;
            e)
              # Write the contents to the stderr directory
              echo "$OPTARG" > "$errors_dir/$errors_count"
              errors_count=$((errors_count + 1))
              ;;
            r)
              # Append the status code to a space-delimited sequence
              # Add a space when `status_code` isn't null to avoid leading space
              status_codes="${status_codes-}${status_codes:+ }$OPTARG"
              ;;
            *) shpy_die "Error: Unknown option -$OPTARG" ;;
        esac
    done

    # If there is not one remaining argument for the spy name, display usage
    if [ $# -ne $OPTIND ]; then
      shpy_remove_dir_tree "$outputs_dir" \
        || shpy_die "Error: Failed to remove stdout directory for spy"
      shpy_remove_dir_tree "$errors_dir" \
        || shpy_die "Error: Failed to remove stderr directory for spy"

      printf '%s\n' "$usage"
      return 1
    fi

    _shpyResetSpy "$spy_name"
    _shpySetSpyStatusCodeSequence "$spy_name" "${status_codes:-0}"
    _shpyCreateSpyExecutable "$spy_name"
}

# Alias for `createSpy`
createStub() {
    createSpy "$@"
}

getSpyCallCount() {
    if [ $# -ne 1 ]; then
        echo 'Usage: getSpyCallCount name'
        echo
        echo 'Outputs the number of calls made to the spy'
        return 1
    fi

    _shpyGetDirectoryContentsCount "${_shpy_spies_dir:-shpy_dir_not_set}/$1"
}

wasSpyCalledWith() {
    if [ $# -eq 0 ]; then
        echo 'Usage: wasSpyCalledWith SPY [ARG]...'
        return 1
    fi

    # shellcheck disable=SC2039
    local count current name spy_path

    name=$1
    shift

    current=$(_shpyGetSpyCurent "$name")
    count=$(getSpyCallCount "$name")
    if [ "$current" -ge "$count" ]; then
        echo "Error: spy '$name' has not been called $current time(s)" >&2
        return 1
    fi

    spy_path="$_shpy_spies_dir/$name/$current" \
        _shpyMatchArgs "$@"
}

getArgsForCall() {
    if [ $# -ne 2 ]; then
        echo 'Usage: getArgsForCall SPY CALL_NUMBER' >&2
        return 1
    fi

    # shellcheck disable=SC2039
    local arg_file args call_index i name num_args spy_path res

    name=$1
    call_index=$(($2 - 1))

    if [ -z "${_shpy_spies_dir:+is_set_and_not_null}" ]; then
      echo "Error: no spies have been created" >&2
      return 1
    fi

    spy_path="$_shpy_spies_dir/$name"

    if [ ! -d "$spy_path" ]; then
        echo "Error: spy '$name' has not been set up" >&2
        return 1
    fi

    spy_path="$spy_path/$call_index"
    if [ ! -d "$spy_path" ]; then
        echo "Error: spy '$name' has not been called $((call_index + 1)) times" >&2
        return 1
    fi

    num_args=$(find "$spy_path" -maxdepth 1 -type f | wc -l)

    i=0
    res=""
    while [ "$i" -le "$num_args" ]; do
        arg_file="$spy_path/$i"
        if [ -f "$arg_file" ]; then
            args=$(cat "$arg_file")
            if printf "%s" "$args" | grep -qe "\\s"; then
                args="\"$args\""
            fi

            if [ ${#res} -gt 0 ]; then
                res=$(printf "%s %s" "$res" "$args")
            else
                res="$args"
            fi
        fi

        i=$((i + 1))
    done

    echo "$res"
}

examineNextSpyCall() {
    # shellcheck disable=SC2039
    local current

    if [ $# -eq 0 ]; then
        echo 'Usage: examineNextSpyCall SPY'
        return 1
    fi

    current=$(_shpyGetSpyCurent "$1")
    _shpySetSpyCurent "$1" $(( current + 1 ))
}

cleanupSpies() {
    if [ -n "${_shpy_inited+is_set}" ]; then
      unset -v _shpy_inited
    fi

    if [ -n "${_shpy_spies_dir+is_set}" ]; then
      # Remove the shpy bin directory from the path using parameter expansion
      PATH="${PATH%$_shpy_spies_dir/bin:*}${PATH#*$_shpy_spies_dir/bin:}"
      export PATH

      find "$_shpy_spies_dir" -maxdepth 1 -type f -exec sh -c '_shpyResetSpy "$1"' _ {} \;

      shpy_remove_dir_tree "$_shpy_spies_dir" || shpy_die "Error: \`shpy_remove_dir_tree '$_shpy_spies_dir'\` failed"

      unset -v _shpy_spies_dir
    fi
}

# PRIVATE API  .-.     .-.     .-.     .-.     .-.     .-.     .-.     .-.
# `._.'   `._.'   `._.'   `._.'   `._.'   `._.'   `._.'   `._.'   `._.'   `

# Creates a temporary shpy directory and adds the bin directory to the path
# This function does not run again until `cleanupSpies` is called
_shpyInit() {
    # Do nothing if shpy is initialized
    if [ -n "${_shpy_inited+is_set}" ]; then
        return
    fi

    # Mark shpy as initialized and create a temp directory to work from
    _shpy_inited=1
    _shpy_spies_dir=$(shpy_make_temp_dir) \
      || shpy_die "Error: Failed to create shpy working directory"

    # Ensure child shell processes have access to these variables
    export _shpy_inited
    export _shpy_spies_dir

    # Create the shpy bin directory and prepend it to the path
    shpy_ensure_dir "$_shpy_spies_dir/bin/"
    PATH="$_shpy_spies_dir/bin:$PATH"
    export PATH
}

# Removes the spy directory and resets all environment variables for the spy
# $1 - Name of the spy to reset
_shpyResetSpy() {
    shpy_remove_dir_tree "$_shpy_spies_dir/$1" \
      || shpy_die "Error: Failed to remove spy directory"

    unset "_shpy_$1_status_codes" "$1_output" "_shpy_$1_current" "$1"
}

# Creates an executable shell script for a spy in `$_shpy_spies_dir/bin/`
# $1 - Name of the spy to create an executable for
_shpyCreateSpyExecutable() {
    # shellcheck disable=SC2039
    local spy_file

    spy_file="$_shpy_spies_dir/bin/$1"

    printf '#!/usr/bin/env sh\n' > "$spy_file"
    printf '. %s\n' "$SHPY_PATH" >> "$spy_file"
    printf '_shpyRunSpy "%s" "$@"\n' "$1" >> "$spy_file"
    chmod +x "$spy_file"
}

_shpyGetSpyCurent() {
    # shellcheck disable=SC2039
    local current
    eval current="\${_shpy_${1}_current-0}"
    printf '%s\n' "$current"
}

_shpySetSpyCurent() {
    eval "_shpy_$1_current=$2"
    eval export "_shpy_$1_current"
}

# Outputs the number of files in the given directory
# $1 - Path to the directory
_shpyGetDirectoryContentsCount() {
    if [ -d "$1" ]; then
      find "$1" -maxdepth 1 ! -path "$1" | wc -l
    else
      echo 0
    fi
}

_shpyMatchArgs() {
    # shellcheck disable=SC2039
    local arg argCount i

    # `spy_path` is set in the environment before invoking this function
    argCount=$(_shpyGetDirectoryContentsCount "$spy_path")
    if [ "$argCount" -ne $# ]; then
        return 1
    fi

    i=0
    while [ "$i" -lt "$argCount" ]; do
        arg=$(cat "$spy_path/$i")
        if [ "$arg" != "$1" ]; then
            return 1
        fi

        shift
        i=$(( i + 1 ))
    done

    return 0
}

# Runs the spy with given arguments
# $1 - Name of the spy to run
# $... - Arguments to the spy
_shpyRunSpy() {
    _shpySaveSpyCallArgs "$@"
    _shpyPrintSpyOutput "$1"
    _shpyPrintSpyErrorOutput "$1"
    _shpyGetSpyReturnStatus "$1"
}

# Saves the arguments for the latest invocation of a spy
# $1 - Name of the spy
# $... - Arguments passed to the spy
_shpySaveSpyCallArgs() {
    # shellcheck disable=SC2039
    local arg arg_index current_call_index spy_call_path

    # The current call index is the total number of calls before this one
    current_call_index=$(getSpyCallCount "$1")

    # Create a directory for the arguments to the call
    spy_call_path="$_shpy_spies_dir/$1/$current_call_index"
    shpy_ensure_dir "$spy_call_path" \
      || shpy_die "Error: Failed to create directory for spy arguments"

    # Remove the spy name from the front of the arguments list
    shift

    # Create a numbered file for each argument to the call
    arg_index=0
    for arg in "$@"; do
        printf '%s' "$arg" > "$spy_call_path/$arg_index"
        arg_index=$(( arg_index + 1 ))
    done
}

# Sends output to stdout for the latest call of a spy
# $1 - Name of the spy to print output
_shpyPrintSpyOutput() {
    # shellcheck disable=SC2039
    local current_call_index outputs_dir output_fixture

    # Specify the outputs directory and current call index
    outputs_dir="$_shpy_spies_dir/outputs/$1"
    current_call_index=$(( $(getSpyCallCount "$1") - 1 ))

    # Start from the current call index and decrease until output is found
    while [ $current_call_index -ge 0 ]; do
        output_fixture="$outputs_dir/$current_call_index"
        current_call_index=$(( current_call_index - 1 ))

        if [ -f "$output_fixture" ]; then
          cat "$output_fixture"
          break
        fi
    done
}

# Sends output to stderr for the latest call of a spy
# $1 - Name of the spy to print output
_shpyPrintSpyErrorOutput() {
    # shellcheck disable=SC2039
    local current_call_index errors_dir error_fixture

    # Specify the errors directory and current call index
    errors_dir="$_shpy_spies_dir/errors/$1"
    current_call_index=$(( $(getSpyCallCount "$1") - 1 ))

    # Start from the current call index and decrease until output is found
    while [ $current_call_index -ge 0 ]; do
        error_fixture="$errors_dir/$current_call_index"
        current_call_index=$(( current_call_index - 1 ))

        if [ -f "$error_fixture" ]; then
          cat "$error_fixture" >&2
          break
        fi
    done
}

# Returns the status code for the latest call of a spy
# $1 - Name of the spy to return the status code for
_shpyGetSpyReturnStatus() {
    # shellcheck disable=SC2039
    local status_codes status_code

    eval status_codes="\$_shpy_$1_status_codes"

    # Status codes are a space-delimited list of integers
    # Get the list item at the current call count index
    status_code="$(echo "$status_codes" | cut -d' ' -f"$(getSpyCallCount "$1")")"

    # If no status was returned for the current call, use the final status
    if [ -z "${status_code:+is_not_null}" ]; then
      status_code=${status_codes##* }
    fi

    return "$status_code"
}

# Sets and exports the status codes returned by a spy in the environment
# $1 - Name of the spy
# $2 - Space-delimited list of integer status codes
_shpySetSpyStatusCodeSequence() {
    eval "_shpy_$1_status_codes=\$2"
    export "_shpy_$1_status_codes"
}

##### External Interface #####

# Break path caching to ensure spies come first in the path
_shpy_break_path_cache() {
    PATH="$PATH"
    export PATH
}

shpy_make_temp_dir() {
    command -p mktemp -d shpy.XXXXXX
    _shpy_break_path_cache
}

shpy_ensure_dir() {
    command -p mkdir -p -- "$1"
    _shpy_break_path_cache
}

shpy_remove_dir_tree() {
    command -p rm -rf -- "$1"
    _shpy_break_path_cache
}

shpy_die() {
    echo "${1:-"Error: aborting"}" >&2
    exit "${2:-1}"
}
